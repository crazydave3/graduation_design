<html>

<body>
    <!-- <button onclick="a()">a</button> -->
    <img id="img1">
    <div style="background-color: rgba(16, 24, 40, 0.05)">#F4EBFF</div>

    <div style="background-color: #ced4da"> #E9D7FE</div>
</body>

<script>
    const c = []
    
    console.log(c.some((tier) => tier.onSale),'111');
    // console.log(typeof (false));
    // console.log({});
    // window.localStorage.setItem(
    //     'a',
    //     {}
    // )
    // const b = window.localStorage.getItem('a')
    // const test = () => {
    //     try {
    //         JSON.parse("undefined")
    //     } catch (error) {
    //         console.error(error);
    //         return 'wwww'
    //     }
    //     return '1111'
    // }
    // const a = test()
    // console.log(a);

    // console.log( JSON.parse('262b6f9a4a70487cb279-92b66059ba4a'));
    //插入排序:
    // const arr = [7, 6, 9, 3, 1, 5, 2, 4]
    // const swap = (a,b) => {
    //   const swap = arr[a]
    //   arr[a] = arr[b]
    //   arr[b] = swap
    // }
    // let num = 0
    // for (i = 1; i < arr.length; i++) {
    //   for (j = i - 1; j >= 0; j--) {
    //     num++
    //     if (arr[j+1] < arr[j]) {
    //       swap(j+1, j)
    //     } else break
    //   }
    // }
    // console.log(num);
    // console.log(arr);

    //希尔排序
    // const arr1 = [7, 6, 9, 3, 1, 5, 2, 4]
    // let num = 0
    // min = parseInt(arr1.length / 2)
    // for (i = min; i > 0; i = parseInt(i / 2)) {
    //   for (j = i; j < arr1.length; j++) {
    //     const swap = arr1[j]
    //     for (k = j; k >= i && swap < arr1[k - i]; k -= i) {
    //       num++
    //       arr1[k] = arr1[k - i]
    //     }
    //     arr1[k] = swap
    //   }
    // }
    // console.log(num);
    // console.log(arr1);
    // let img = []
    // const Img = document.getElementById("img1")
    // setPic = async () => {
    //   await fetch('http://shibe.online/api/shibes').then(res => {
    //     return res.json().then(jsondata => {
    //       if (res.ok) {
    //         img = jsondata
    //         return jsondata
    //       }
    //     })
    //   })
    //   Img.src = img[0]
    // }
    // setPic()
    // var twoSum = function (nums, target) {
    //   const newnums = {}
    //   for (i = 0; i < nums.length; i++) {
    //     const curnum = nums[i]
    //     const need = target - curnum
    //     if (newnums[curnum] !== undefined) {
    //       return [ newnums[curnum], i]
    //     } else {
    //       newnums[need] = i
    //     }
    //   }
    // };
    var twoSum = function (nums, target) {
        const newnums = new Map()
        for (i = 0; i < nums.length; i++) {
            const need = target - nums[i]
            if (newnums.has(need)) {
                return [newnums.get(need), i]
            }
            else (newnums.set(nums[i], i))
        }
    };
    // console.log(twoSum([2, 7, 11, 15], 9));
    // console.log(!'');
    var removeElement = function (nums, val) {
        let startIndex = nums.length - 1
        for (i = startIndex; i >= 0; i--) {
            if (nums[i] === val) {
                nums.splice(i, 1)
            }
        }
    };
    var merge = function (nums1, m, nums2, n) {
        let nindex = n - 1
        let mindex = m - 1
        for (i = m + n - 1; i >= 0; i--) {
            if (nums1[mindex] <= nums2[nindex] || mindex < 0) {
                nums1[i] = nums2[nindex]
                nindex--
            } else if (nums1[mindex] > nums2[nindex] || nindex < 0) {
                nums1[i] = nums1[mindex]
                mindex--
            }
        }
    };
    var removeDuplicates = function (nums) {
        // const map = new Map()
        // for(i = nums.length - 1;i>=0; i--) {
        //     if (map.has(nums[i])) {
        //         nums.splice(i,1)
        //     } else {
        //         map.set(nums[i], i)
        //     }
        // }
        if (nums.length == 0) return 0;
        let i = 0;
        for (let j = 1; j < nums.length; j++) {
            if (nums[j] !== nums[i]) {
                nums[++i] = nums[j]
            }
        }
        console.log(nums);
        return i + 1;

    };
    var removeDuplicatesV2 = function (nums) {
        const map = new Map()
        for (i = nums.length - 1; i >= 0; i--) {
            if (map.has(nums[i])) {
                const all = map.get(nums[i]) + 1
                map.set(nums[i], all)
                if (all > 2) {
                    nums.splice(i, 1)
                }
            } else {
                map.set(nums[i], 1)
            }
        }
        console.log(map);
    }
    var majorityElement = function (nums) {
        // const map = new Map()
        // nums.forEach((num) => {
        //   if (!map.has(num)) {
        //     map.set(num, 1)
        //   } else {
        //     const all = map.get(num)
        //     map.set(num, all + 1)
        //   }
        // })
        // for (let key of map) {
        //   if (key[1] > nums.length / 2) {
        //     return key[0]
        //   }
        // }
        const newArr = nums.sort()
        let show = 1
        for (let i = 0; i < nums.length; i++) {
            if (i !== 0) {
                if (newArr[i] === newArr[i - 1]) {
                    show += 1
                } else {
                    show = 1
                }
            }
            if (show > nums.length / 2) {
                return newArr[i]
            }
        }
    };

    var maxProfit = function (prices) {
        const len = prices.length
        // let max = prices[len - 1]
        // let maxIndex = len - 1
        // let profit = 0
        // for (i = len - 1; i >= 0; i--) {
        //     if (max < prices[i]) {
        //         max = prices[i]
        //         maxIndex = i
        //     }
        //     if (max - prices[i] > profit && maxIndex > i) {
        //         profit = max - prices[i]
        //     }
        // }
        let curMin = prices[0]
        let profit = 0
        for (let i = 0; i < prices.length; i++) {
            if (prices[i] < curMin) {
                curMin = prices[i]
                continue;
            }
            profit = Math.max(prices[i] - curMin, profit)
        }
        return profit
    };
    var maxProfitV2 = function (prices) {
        const len = prices.length
        let curMin = prices[0]
        let profit = 0
        let allProfit = 0

        for (let i = 0; i < prices.length; i++) {
            if (prices[i] < curMin) {
                curMin = prices[i]
                continue
            }
            if (prices[i] - curMin > profit) {
                profit = prices[i] - curMin
                if (prices[i] >= prices[i + 1]) {
                    allProfit += profit
                    curMin = prices[i + 1]
                    profit = 0
                }
                if (i + 1 === prices.length) {
                    allProfit += profit
                }

            }
        }
        return allProfit
    };
    // maxProfitV2([5, 2, 3, 2, 6, 6, 2, 9, 1, 0, 7, 4, 5, 0])

    var canJump = function (nums) {
        let max = 0
        for (let i = 0; i < nums.length; i++) {
            if (max < i) return false
            max = max > nums[i] + i ? max : nums[i] + i
        }
    };
    // canJump([5, 9, 3, 2, 1, 0, 2, 3, 3, 1, 0, 0])

    var canJump2 = function (nums) {
        let j = 0
        let end = 0
        let jump = 0
        for (i = 0; i < nums.length; i++) {
            if (nums[i] + i > j) {
                j = nums[i] + i
            }
            if (i === end) {
                end = j
                jump++
            }
        }
        return jump

    };
    // canJump2([7, 0, 9, 6, 9, 6, 1, 7, 9, 0, 1, 2, 9, 0, 3])

    var hIndex = function (citations) {
        // const len = citations.length
        // for (let i = len; i > 0; i--) {
        //     if (citations[len - i] >= i) {
        //         return i
        //     }
        // }
        // return 0

        citations.sort((a, b) => a - b);
        let h = 0, i = citations.length - 1;
        while (i >= 0 && citations[i] > h) {
            h++;
            i--;
        }
        return h;
    }
    // hIndex([3, 0, 1, 6, 5])

    var isPalindrome = function (s) {
        const reg = /\W|_/g
        const str1 = s.toLowerCase().replace(reg, '')
        let f1 = 0
        let f2 = str1.length - 1
        while (f1 < f2) {
            if (str1[f1] !== str1[f2]) {
                return false
            }
            f1++
            f2--
        }
        return true
    };
    // isPalindrome('A man, a plan, a canal: Panama')

    var isSubsequence = function (s, t) {
        // if (s.length === 0) return true
        // let f1 = -1
        // let f2 = 0
        // while (f2 < t.length) {
        //     if (s[f1 + 1] === t[f2]) {
        //         f1++
        //     }
        //     f2++
        // }
        // return f1 === s.length - 1
        if (s.length == 0) return true;
        let num = 0;
        for (let i = 0; i < s.length; i++) {
            if (t.indexOf(s[i], num) !== -1) {
                if (num > t.indexOf(s[i], num)) {
                    return false;
                }
                num = t.indexOf(s[i], num) + 1;
            } else {
                return false;
            }
        }
        return true;
    };
    // isSubsequence('acb', 'ahgbdc')
    var romanToInt = function (s) {
        const roman = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 }
        let i = 0
        let num = 0
        while (i < s.length) {
            if (roman[s[i]] < roman[s[i + 1]]) {
                num -= roman[s[i]]
            } else {
                num += roman[s[i]]
            }
            i++
        }
        return num
    }
    // romanToInt('MCMXCIV')

    var lengthOfLastWord = function (s) {
        // const arr = s.split(' ').filter(a => a !== '')
        // return arr[arr.length - 1].length

        // const len = s.length
        // let isWord = false
        // let index = 0
        // for (let i = len - 1; i > 0; i--) {
        //     if (s[i] !== ' ') {
        //         isWord = true
        //     }
        //     if (s[i] === ' ' && isWord) {
        //         index = i
        //         break
        //     }
        // }
        // const newIndex = index === 0 ? 0 : index + 1
        // return s.slice(newIndex).replace(/ /g,'').length

        // const str1 = s.trim()
        // const index = str1.lastIndexOf(' ')
        // return str1.slice(index + 1).length

        const len = s.length
        let num = 0
        for (let i = len - 1; i >= 0; i--) {
            if (s[i] !== ' ') {
                num++
            } else if (num > 0) {
                break
            }
        }
        return num
    };
    // lengthOfLastWord("a")
    var longestCommonPrefix = function (strs) {
        // const len = strs.length
        // let str = ''
        // let num = 0
        // let index = len - 1
        // if (len === 1) return strs[0]
        // if (strs.indexOf("") !== -1) return ""
        // while (true) {
        //     if (index === len - 1) {
        //         str = strs[index][num]
        //     } else if (strs[index][num] !== str || num === strs[index].length) {
        //         break
        //     }
        //     index--
        //     if (index < 0) {
        //         num++
        //         index = len - 1
        //     }
        // }
        // return strs[0].slice(0, num)

        // if (strs.length == 0)
        //     return "";
        // let ans = strs[0];
        // for (let i = 1; i < strs.length; i++) {
        //     let j = 0;
        //     for (; j < ans.length && j < strs[i].length; j++) {
        //         if (ans[j] != strs[i][j])
        //             break;
        //     }
        //     ans = ans.substr(0, j);
        //     if (ans === "")
        //         return ans;
        // }
        // return ans;

        strs.sort((a, b) => a.length - b.length)
        let str = strs[0]
        let index = 1
        const len = strs.length
        while (true) {
            if (index >= len) {
                return str
            }
            const strlen = str.length
            if (strs[index].substr(0, strlen) !== str) {
                index = 0
                str = strs[0].substr(0, strlen - 1)
            }
            if (str === "") return ""
            index++

        }
    };
    // longestCommonPrefix(["flower", "flow", "flight"])

    var strStr = function (haystack, needle) {
        // let i = 0
        // let j = 0
        // const needleLen = needle.length
        // const haystackLen = haystack.length
        // while (j < needleLen && i < haystackLen) {
        //     if (needle[j] === haystack[i+j]) {
        //         j++
        //     } else {
        //         i++
        //         j = 0
        //     }
        // }
        // if (j !== needleLen) return -1
        // return i
        return haystack.indexOf(needle)
    };
    // strStr("mississippi", "pi")

    var canConstruct = function (ransomNote, magazine) {
        // let i = 0
        // const len1 = ransomNote.length
        // let str = magazine
        // while (i < len1) {
        //     const index = str.indexOf(ransomNote[i])
        //     if (index !== -1) {
        //         i++
        //         str = str.slice(0, index) + str.slice(index + 1)
        //     } else {
        //         break
        //     }
        // }
        // return i === len1

        // const map = new Map()
        // for (let i in magazine) {
        //     const str = map.get(magazine[i])
        //     if (str) {
        //         map.set(magazine[i], str + 1)
        //     } else {
        //         map.set(magazine[i], 1)
        //     }
        // }
        // for (let j in ransomNote) {
        //     let str = map.get(ransomNote[j])
        //     if (!str || str-- < 0) {
        //         return false
        //     }
        //     map.set(ransomNote[j], str)
        // }
        // return true

        if (ransomNote.length > magazine.length) {
            return false;
        }
        const cnt = new Array(26).fill(0);
        for (const c of magazine) {
            cnt[c.charCodeAt() - 'a'.charCodeAt()]++;
        }
        for (const c of ransomNote) {
            cnt[c.charCodeAt() - 'a'.charCodeAt()]--;
            if (cnt[c.charCodeAt() - 'a'.charCodeAt()] < 0) {
                return false;
            }
        }
        return true;
    };
    // canConstruct('aa', 'ab')

    var isIsomorphic = function (s, t) {
        // const map = new Map()
        // const map1 = new Map()
        // const sLen = s.length
        // const tLen = t.length
        // if (sLen !== tLen) return false
        // for (let i = 0; i < sLen; i++) {
        //     const str = map.get(s[i])
        //     const str1 = map1.get(t[i])
        //     if ((str || str1) && (t[i] !== str || s[i] !== str1)) {
        //         return false
        //     } else {
        //         map.set(s[i], t[i])
        //         map1.set(t[i], s[i])
        //     }
        // }
        // return true
        const map = {}
        const map1 = {}
        const sLen = s.length
        for (let i = 0; i < sLen; i++) {
            const str = s[i]
            const str1 = t[i]
            if ((map1[str1] && str !== map1[str1]) || (map[str] && str1 !== map[str])) {
                return false
            } else {
                map[str] = str
                map1[str1] = str1
            }
        }
        return true
    };
    // isIsomorphic('badc', 'baba')
    var wordPattern = function (pattern, s) {
        // const arr = s.split(' ')
        // const map = new Map()
        // const map1 = new Map()
        // const sLen = arr.length
        // const pLen = pattern.length
        // if (pLen !== sLen) return false
        // for (let i = 0; i < sLen; i++) {
        //     const str = map.get(pattern[i])
        //     const str1 = map1.get(arr[i])
        //     if ((str && str !== arr[i]) || (str1 && str1 !== pattern[i])) {
        //         return false
        //     } {
        //         map.set(pattern[i], arr[i])
        //         map1.set(arr[i], pattern[i])
        //     }
        // }
        // return true

        const a = s.split(' '), len = pattern.length
        if (len !== a.length) return false
        let sums = '', sump = '', i = -1
        while (++i < len) {
            sums += a.indexOf(a[i])
            sump += pattern.indexOf(pattern[i])
        }
        return sums === sump
    };
    // wordPattern('abba', 'dog cat cat dog')

    var isHappy = function (n) {
        const getNum = (n) => {
            let sum = 0
            while (n) {
                sum += (n % 10) ** 2
                n = Math.floor(n / 10)
            }
            return sum
        }
        // let fast = getNum(getNum(n))
        // let slow = getNum(n)
        // while (fast !== slow) {
        //     fast = getNum(getNum(fast))
        //     slow = getNum(slow)
        // }
        // return slow === 1

        const map = new Map()
        while (1) {
            if (map.has(n)) return false
            if (n === 1) return true
            map.set(n, 1)
            n = getNum(n)
        }
    };
    // isHappy(2)
    var isPalindrome = function (x) {
        // if (x < 0 || (!(x % 10) && x)) return false
        // let x2 = x
        // let num = 0
        // while (x2) {
        //     num = num * 10 + x2 % 10
        //     x2 = Math.floor(x2 / 10)
        // }
        // return x === num

        // if (x < 0) return false
        // if (x < 10) return true
        // let n = 10 ** Math.floor(Math.log10(x))
        // while (n > 1 && x > 0) {
        //     if (Math.floor(x / n) !== x % 10) return false
        //     x = Math.floor(x % n / 10)
        //     n /= 100
        // }
        // return true

        if (x < 0 || (!(x % 10) && x)) return false
        let num = x % 10
        while (num < x) {
            x = Math.floor(x / 10)
            num = num * 10 + x % 10
        }
        return x === num || x === Math.floor(num / 10)

    };
    // isPalindrome(10)
    var plusOne = function (digits) {
        const len = digits.length
        let i = len - 1
        while (i >= 0 && digits[i] === 9) {
            digits[i] = 0
            i--
        }
        if (i === -1) {
            digits.unshift(1)
        } else {
            digits[i] += 1
        }
        return digits
    }
    // plusOne([9, 9])

    var mySqrt = function (x) {
        let i = Math.floor(x / 2)
        while (i * i > x) {
            i = Math.floor(i / 2)
        }
        while ((i + 1) * (i + 1) <= x) {
            i++
        }
        return i
    };
    // mySqrt(0)
    var containsNearbyDuplicate = function (nums, k) {
        const map = new Map()
        const len = nums.length
        let near = false
        for (i = len - 1; i >= 0; i--) {
            const num = map.get(nums[i])
            if (num && num - i <= k) {
                near = true
            } else {
                map.set(nums[i], i)
            }
        }
        return near
    };
    // containsNearbyDuplicate([1, 2, 3, 1], 3)
    var addBinary = function (a, b) {
        // let abLen = a.length - b.length
        // while (abLen > 0) {
        //     b = '0' + b
        //     abLen--
        // }
        // while (abLen < 0) {
        //     a = '0' + a
        //     abLen++
        // }
        // const aLen = a.length
        // let addOne = 0
        // const getNum = (a,b) => {
        //     let sum = a + b + addOne
        //     addOne = sum >= 2 ? 1 : 0
        //     return sum % 2
        // }
        // let c = ''
        // for (i = aLen - 1; i >= 0; i--) {
        //     c = getNum(parseInt(a[i]),parseInt(b[i])).toString() + c
        // }
        // if (addOne) {
        //     c = '1' + c
        // }
        // return c

        let ans = "";
        let ca = 0;
        for (let i = a.length - 1, j = b.length - 1; i >= 0 || j >= 0; i--, j--) {
            let sum = ca;
            sum += i >= 0 ? parseInt(a[i]) : 0;
            sum += j >= 0 ? parseInt(b[j]) : 0;
            ans += sum % 2;
            ca = Math.floor(sum / 2);
        };
        ans += ca == 1 ? ca : "";
        return ans.split('').reverse().join('');
    }
    // addBinary('11', '1')
    var summaryRanges = function (nums) {
        const len = nums.length
        if (len === 0) return []
        let start = nums[0]
        let end = nums[0]
        let arr = []
        for (i = 1; i <= len; i++) {
            if (nums[i] !== nums[i - 1] + 1) {
                if (start === end) {
                    arr.push(start.toString())
                } else {
                    arr.push(`${start}->${end}`)
                }
                start = nums[i]
            }
            end = nums[i]
        }
        return arr
    };
    // summaryRanges([0, 2, 3, 4, 6, 8, 9])

    var isValid = function (s) {
        const len = s.length
        const arr = []
        const obj = { '(': ')', '[': ']', '{': '}' }
        let i = 0
        while (i < len) {
            const arrLen = arr.length
            if (s[i] === '(' || s[i] === '[' || s[i] === '{') {
                arr.push(s[i])
                i++
                continue
            }
            if (obj[arr[arrLen - 1]] !== s[i]) {
                return false
            }
            arr.pop()
            i++
        }
        return arr.length === 0
        // let len = s.length;
        // if (len % 2 !== 0) {
        //     return false;
        // }
        // let length = len / 2;
        // for (let i = 0; i < length; i++) {
        //     s = s.replace("()", "");
        //     s = s.replace("{}", "");
        //     s = s.replace("[]", "");
        // }
        // return s.length === 0;
    };

    // isValid("(){{{}}}")

    var maxDepth = function (root) {
        return root === null ? 0 : 1 + Math.max(maxDepth(root.left), maxDepth(root.right))
    };

    var isSameTree = function (p, q) {
        // if (!p || !q) {
        //     if (!p && !q) return true
        //     return false
        // }
        // if (p.val !== q.val) return false
        // let left = false
        // let right = false
        // switch (true) {
        //     case p.left && !q.left:
        //         break
        //     case !p.left && q.left:
        //         break
        //     case !p.left && !q.left:
        //         left = true
        //         break
        //     default:
        //         left = isSameTree(p.left, q.left)
        //         break
        // }
        // switch (true) {
        //     case p.right && !q.right:
        //         break
        //     case !p.right && q.right:
        //         break
        //     case !p.right && !q.right:
        //         right = true
        //         break
        //     default:
        //         right = isSameTree(p.right, q.right)
        //         break

        // }
        // return left && right

        if (p === null && q === null) {
            return true
        } else if (p === null || q === null) {
            return false
        } else if (p.val !== q.val) {
            return false
        } else {
            const left = isSameTree(p.left, q.left)
            const right = isSameTree(p.right, q.right)
            return left && right
        }
    };

    var invertTree = function (root) {
        // if (!root) return root
        // if (root.left) {
        //     invertTree(root.left)
        // }
        // if (root.right) {
        //     invertTree(root.right)
        // }
        // if (root.left || root.right) {
        //     const left = root.left
        //     root.left = root.right
        //     root.right = left
        // }
        // return root

        if (!root) return root
        const left = invertTree(root.left)
        const right = invertTree(root.right)
        root.left = right
        root.right = left
        return root
    };
    var isSymmetric = function (root) {
        // if (!root) return true
        // const leftRight = (left, right) => {
        //     if (!left && !right) return true
        //     if (!left || !right) return false
        //     const isSame = left.val === right.val
        //     return isSame && leftRight(left.left, right.right) && leftRight(right.left, left.right)
        // }
        // const rightLeft = (right, left) => {
        //     if (!left && !right) return true
        //     if (!left || !right) return false
        //     const isSame = right.val === left.val
        //     return isSame && leftRight(left.left, right.right) && leftRight(right.left, left.right)
        // }
        // const left = root.left
        // const right = root.right
        // return leftRight(left, right) && rightLeft(right, left)

        // if (!root) {
        //     return true;
        // }

        if (!root) {
            return true;
        }
        const isSame = (left, right) => {
            if (!left && !right) return true
            if (!left || !right) return false
            const isSame1 = left.val === right.val
            return isSame1 && isSame(left.left, right.right) && isSame(right.left, left.right)
        }
        return isSame(root.left, root.right)
    };

    var hasPathSum = function (root, targetSum) {
        if (!root) return false
        targetSum -= root.val
        return (targetSum === 0 && !root.left && !root.right) || hasPathSum(root.left, targetSum) || hasPathSum(root.right, targetSum)
    };

    var countNodes = function (root) {
        if (!root) return 0
        return 1 + countNodes(root.left) + countNodes(root.right)
    };

    var sortedArrayToBST = function (nums) {
        const len = nums.length
        if (len === 0) return null
        const mid = Math.floor((len - 1) / 2)
        const node = new TreeNode(nums[mid])
        node.left = sortedArrayToBST(nums.slice(0, mid))
        node.right = sortedArrayToBST(nums.slice(mid + 1))
        return node
    };
    var productExceptSelf = function (nums) {
        const len = nums.length
        const answer = new Array(len).fill(1)
        let leftSum = 1
        let rightSum = 1
        let i = 0
        while (i < len) {
            answer[i] *= leftSum
            answer[len - i - 1] *= rightSum
            leftSum *= nums[i]
            rightSum *= nums[len - i - 1]
            i++
        }
        return answer
    };
    // productExceptSelf([1, 2, 3, 4])

    var canCompleteCircuit = function (gas, cost) {
        const len = gas.length
        let i = 0
        let index = 0
        let run = 0
        let useGas = 0
        while (i < len) {
            useGas += gas[i] - cost[i]
            run += gas[i] - cost[i]
            if (run < 0) {
                index = i + 1
                run = 0
            }
            i++
        }
        return useGas >= 0 ? index : -1
    };
    // canCompleteCircuit([1, 2, 3, 4, 5], [3, 4, 5, 1, 2])

    var reverseWords = function (s) {
        // const str = s.trim()
        // const arr = str.split(' ')
        // const len = arr.length
        // let newStr = ''
        // let i = -1
        // while(i < len - 1) {
        //     i++
        //     const word = arr[len - i - 1]
        //     if (word === '') continue
        //     newStr += word.trim()
        //     if (i < len - 1) {
        //         newStr += ' '
        //     }
        // }
        // return newStr
        const str = s.trim()
        const len = str.length
        let word = ''
        let newStr = ''
        let i = 0
        let first = true
        while (i < len) {
            if (str[i] !== ' ') {
                word += str[i]
                if (str[i + 1] === ' ' || !str[i + 1]) {
                    if (first) {
                        newStr = word
                        first = false
                    } else {
                        newStr = word + ' ' + newStr
                    }
                    word = ''
                }
            }
            i++
        }
    };
    // reverseWords('the sky is blue')

    var convert = function (s, numRows) {
        if (numRows < 3) return s
        const len = s.length
        let i = 0
        let j = 0
        let plus = true
        const arr = Array(numRows).fill('')
        while (i < len) {
            arr[j] += s[i]
            i++
            if (plus) {
                j++
            } else {
                j--
            }
            switch (j) {
                case numRows - 1:
                    plus = false
                    break
                case 0:
                    plus = true
                    break
            }
        }
        const str = arr.join('')
        return arr.join('')
    };
    // convert('PAYPALISHIRING', 3)

    var intToRoman = function (num) {
        let newNum = num
        let str = ''
        const value = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]
        const mapValue = new Map([
            [1000, 'M'],
            [900, 'CM'], [500, 'D'], [400, 'CD'], [100, 'C'],
            [90, 'XC'], [50, 'L'], [40, 'XL'], [10, 'X'],
            [9, 'IX'], [5, 'V'], [4, 'IV'], [1, 'I'],
        ])

        while (newNum > 0) {
            for (key of value) {
                if (newNum >= key) {
                    str += mapValue.get(key)
                    newNum -= key
                    break
                }
            }
            // switch (true) {
            //     case newNum >= 1000:
            //         newNum -= 1000
            //         str += 'M'
            //         break
            //     case newNum >= 900:
            //         newNum -= 900
            //         str += 'CM'
            //         break
            //     case newNum >= 500:
            //         newNum -= 500
            //         str += 'D'
            //         break
            //     case newNum >= 400:
            //         newNum -= 400
            //         str += 'CD'
            //         break
            //     case newNum >= 100:
            //         newNum -= 100
            //         str += 'C'
            //         break
            //     case newNum >= 90:
            //         newNum -= 90
            //         str += 'XC'
            //         break
            //     case newNum >= 50:
            //         newNum -= 50
            //         str += 'L'
            //         break
            //     case newNum >= 40:
            //         newNum -= 40
            //         str += 'XL'
            //         break
            //     case newNum >= 10:
            //         newNum -= 10
            //         str += 'X'
            //         break
            //     case newNum >= 9:
            //         newNum -= 9
            //         str += 'IX'
            //         break
            //     case newNum >= 5:
            //         newNum -= 5
            //         str += 'V'
            //         break
            //     case newNum >= 4:
            //         newNum -= 4
            //         str += 'IV'
            //         break
            //     case newNum >= 1:
            //         newNum -= 1
            //         str += 'I'
            //         break
            // }
        }
        return str
    };
    // intToRoman(2999)
    var candy = function (ratings) {
        const len = ratings.length
        let leftCandy = 1
        let rightCandy = 0
        let allCandy = 0
        let startIndex = 0
        let endIndex = len - 1
        let change = 0
        while (startIndex < len) {
            const start = ratings[startIndex]
            const startRight = ratings[startIndex + 1] || start
            const end = ratings[endIndex]
            const endLeft = ratings[endIndex - 1] || start
            console.log(leftCandy, rightCandy);
            allCandy += (leftCandy + rightCandy)
            if (startIndex === len - 1) break
            if (start < startRight) {
                leftCandy++
            } else {
                // if (start !== startRight && leftCandy !== 1) {
                //     console.log(start,startRight,leftCandy,'sss');
                //     change += 1
                // }
                leftCandy = 1
            }
            if (end < endLeft) {
                rightCandy++
            } else {
                if (rightCandy !== 0 && end !== endLeft) {
                    console.log(end, endLeft, rightCandy, 'eee');
                    change += rightCandy
                }
                rightCandy = 0
            }
            startIndex++
            endIndex--
        }
        console.log(allCandy, change);
        allCandy -= change
        return allCandy
    };
    // 1  2  3  1  1  1  1  2  3  4  5  1  1 = 26  39
    // 0  0  4  3  2  1  0  0  0  0  2  1  0 = 13
    // [1, 2, 7, 6, 3, 2, 1, 2, 3, 4, 5, 2, 1]
    // 1  2  5  4  3  2  1  2  3  4  5  2  1 = 35

    // 1 2 1 1 1
    // 0 1 0 1 0
    // 1 2 1 2 1

    // 1 2 3 1 1 1 1
    // 0 0 4 3 2 1 0 
    // 1 2 5 4 3 2 1
    candy([1, 6, 10, 8, 7, 3, 2])
</script>

</html>